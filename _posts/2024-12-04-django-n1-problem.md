---
layout: post
title:  "DJango에서 N + 1 Problem 해결하는 방법"
date:   2024-12-04 23:00:00 +0900
categories: "Django"
summary: "ORM을 사용하다 보면 두 개 이상의 테이블을 조회하는데 있어 N + 1 문제를 한번씩 마주친다. DJango에서는 어떻게 해결하는지 알아보자."
tags: ["django", "database"]
image: ""
---


# 개요

## N + 1이 뭐에요?

백엔드 프레임워크 또는 다른 라이브러리에서 제공하는 ORM 라이브러리는 데이터베이스와의 상호작용을 편하게 해 준다.
하지만 이걸 아무생각없이 남용을 하게되면, 불필요한 DB 요청을 하게 되는 이슈가 발생하게 되는데, 대표적인 예가 **N + 1 Problem** 이다

**N + 1 Problem** 이란, 두 개의 연결된 테이블을 조회할 때, 하위 테이블을 참조해서 조회하기 위해 상위 테이블에서
조회된 N개의 테이블들을 하나씩 순회하면서 추가로 DB에 요청을 하는 것을 의미한다. 즉, 상위 테이블을 1번 조회하고, 조회된 데이터들을 순회하면서
하위 테이블 조회 요청을 각각 보내, 총 DB에 **N + 1** 개의 요청을 하게 된다고 보면 된다. 이렇게 N이 기하급수적으로 커지게 되면 DB 부하가 커지게 됨은 물론, 서버 성능에도 영향을 미치게 된다.

## 원인

### Lazy Loading

Django를 포함한 여러 ORM 라이브러리들은 Lazy Loading을 지원한다.
Lazy Loading이란, ORM 함수를 사용한다고 해서 바로 사용하지는 않고, 실제 DB 데이터를 사용하려는 시점에서 SQL문이 날라간다.
그렇기 때문에, 유동적으로 쿼리에 쿼리를 추가할 수가 있어 코드를 재활용할 수 있다는 장점이 있다. 하지만 이는 곧, 하위 테이블 데이터의 정보가 필요할 때마다
SQL문을 날리는 N + 1 Problem에 직면하게 된다.


# 해결 방법 

사실 해결 방법은 간단하다. JOIN을 사용하면 된다. 이렇게 되면 쿼리문 1번으로 끝내는 것이 가능하다. 하지만 여기는 RAW Query가 아닌 ORM이기 때문에 다른 방법을 사용해야 한다.


## select_related
JOIN문을 사용하는 함수로, 정참조일 대만 사용가능하고, 역참조는 사용할 수 없다

## prefetch_related
상위 테이블 조회 1번, 하위 테이블 조회 1번, 총 2번만 요청을 한다.
